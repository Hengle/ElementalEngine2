///============================================================================
/// \note   Elemental Engine
///         Copyright (c)  2005-2008 Signature Devices, Inc.
///
///         This code is redistributable under the terms of the EE License.
///
///         This code is distributed without warranty or implied warranty of
///			merchantability or fitness for a particular purpose. See the 
///			EE License for more details.
///
///         You should have received a copy of the EE License along with this
///			code; If not, write to Signature Devices, Inc.,
///			3200 Bridge Parkway Suite 102, Redwood City, CA 94086 USA.
///============================================================================

#if !defined(AFX_RESOURCEPAGE_H__53730D09_4C39_4B92_9A4B_8BE03DAE955F__INCLUDED_)
#define AFX_RESOURCEPAGE_H__53730D09_4C39_4B92_9A4B_8BE03DAE955F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ResourcePage.h : header file
//
#include "ResourceListCtrlEx.h"
#include <map>
#include <set>
#include <queue>
#include <stack>

// how many thumbnails are generated by one step.
#define THUMBNAIL_RECURSION_STEP 1 

struct FILEFOUNDDATA
{
	StdString Filepath;
	FILETIME  LastWrite;
	bool IsDirty;
};

typedef list< FILEFOUNDDATA > FINDDATALIST;

typedef map< DWORD, FILEFOUNDDATA > INDEXTOFILE;

typedef map< DWORD, RESOURCEPAGEINFO* > INDEXTORESOURCE;

typedef map< StdString, INDEXTORESOURCE > FILEPATHTORESOURCEMAP;

/////////////////////////////////////////////////////////////////////////////
// CResourcePage dialog
struct FILEINDEXINFO
{
	FILETIME	m_FileTime;
	DWORD		m_Index;
};

typedef std::map< StdString, FILEINDEXINFO > FILETOINFO;

typedef struct RESOURCEFINDSTEP
{
	HWND	ParentHandle;
	UINT	MaxStep;
	//Must be arrays because of global alloc
	TCHAR	szSearchDirectory[MAX_PATH];
	TCHAR	szExtensions[MAX_PATH];
	FINDDATALIST * ProcessList;
}RESOURCEFINDSTEP;

struct POPULATERESOURCELISTPARAMS
{
	///
	HWND	ParentHandle;
	TCHAR	FilePath[MAX_PATH];
	DWORD	DirtyIndex;
	FILETIME LastWrite;
};

struct FILEREFRESHPARAMS
{
	TCHAR	FilePath[MAX_PATH];
	DWORD	Action;

};

struct BATCHCOMPLETEDTHUMBMSG
{
	int numGenerated;
	RESOURCEPAGEINFO * m_GeneratedResources[THUMBNAIL_RECURSION_STEP];
};
class CIterativeDirectoryRecursion
{
	struct ITERATION_FRAME
	{
		WIN32_FIND_DATA curFileData;
		HANDLE		hSearch;
		StdString	cur_search;
		StdString	DataDirectory;
	};
	stack< ITERATION_FRAME > m_ProcessStack;
	StdString m_Extension;
	StdString m_Directory;
	
	bool CreateSearchFrame( const TCHAR * curdir );
	void IterateSearchFrame();
	void DeinitializeProcessStack();

public:
	CIterativeDirectoryRecursion();
	~CIterativeDirectoryRecursion()
	{
		DeinitializeProcessStack();
	}
	/// \brief Iterates the number of steps and puts the output back in out_list
	///	\params	numSteps = the number of iterations to perform in this call
	///	\params	&out_list = reference to the INDEXTOFILE list to write to
	///	\param	&NotInList = reference to FILETOINFO list to check images against
	///	\param	&countDirty = the number images that need to be redrawn
	///	\param	bRecurse = if true, recurse through all subdirectories
	int DoSteps( int numSteps, INDEXTOFILE &out_list, 
		FILETOINFO &NotInList ,
		int &countDirty,
		bool bRecurse = true);
	/// Resets the directory to recurse in
	void Reset( const TCHAR * dir, const TCHAR * extension );
	const TCHAR * GetDirectory()
	{
		return m_Directory;
	}
	const TCHAR * GetExtension()
	{
		return m_Extension;
	}
};

class CResourcePage : public CPropertyPage
{
	DECLARE_DYNCREATE(CResourcePage)

// Construction
public:
	CResourcePage();
	CResourcePage( RESOURCECOLLECTION *pResourceCollection );
	~CResourcePage();

	void PauseGenerationThread( bool value );
	void AddResource(RESOURCEPAGEINFO *rs);
	/// \brief	Remove a resource from the page
	///			This function is only called upon a resource that is 
	///			in the current ListCtrl (ie. the current directory)
	///	\param	index - the index of the resource in the ListCtrl
	void RemoveResource(UINT index);
	void ClearResources();	
	void RefreshDirectory();

	// sets the resouce dir (if the dir changes, it needs to be updated here as well)
	void SetResouceDirectory( StdString	newDir );
	bool GetSelectedResources( list< RESOURCEPAGEINFO > &InOutList );
	bool SetSelectedResources( list<StdString> &InOutList );
	const TCHAR * GetResourceDirectory();
	const TCHAR * GetExtensionsFilter();	
	const TCHAR * GetName() const;
	bool GetResourceInfoByRelativePath( GETRESOURCEINFOBYRELATIVEPATH * searchparam );
	CBitmap * GetThumbnailFromListIndex( int index );
	
	/// \brief	Set active directory
	///	\param	newDir - StdString of the new directory
	void SetActiveDirectory(StdString &newDir);

// Dialog Data
	//{{AFX_DATA(CResourcePage)
	enum { IDD = IDD_OBJECTS_PAGE };
	CResourceListCtrlEx	m_ResourcesList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CResourcePage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CImageList m_ThumbNails;
	CImageList* m_pDragImage;
	//a list of currently unused listbox entries
	//std::queue< int > m_EmptyIndices;
	CBitmap *	m_BlankBitmap;
	BOOL		m_bDragging;
	int			m_nDragIndex, m_nDropIndex;
	CWnd*		m_pDropWnd;
	StdString   m_szExtensions;
	StdString	m_szResourceDirectory;
	StdString	m_szName;
	
	CMenu		m_ViewMenu;
	int			m_iView;

	//maps filepath infos of thumbnail to the listctrl 
	FILETOINFO		m_ValidResources;
	// maps indexes in listctrl to the thumbnails filepath info
	INDEXTOFILE		m_UnprocessedThumbnails;
	// list of thumbnail filepath infos that are queued to be drawn
	FINDDATALIST	m_DrawThumbnails;
	// maps filepath to resources
	FILEPATHTORESOURCEMAP	m_ResourceMap;

	// the active directory
	StdString	m_szActiveDirectory;

	//Member functions-----------------------------------------------------------------------------------
	void BuildValidResourceList();
	void BuildThumbnailQueueList();
	
	void CacheThumbnails( TCHAR * directory );
	bool LoadCachedThumbnails( TCHAR * directory );
	// not in use anymore
	void LoadSaveListInformation( CArchive * archive );
	void ArchiveTChar( CArchive * archive, TCHAR * str, DWORD maxLength );
	
	void CreateDummyBitmap();
	void RemoveDummyBitmap();

	void SetView( DWORD iView );

	void GetImageFromList(CImageList *lstImages, int nImage, CBitmap* destBitmap);

	/// \brief	Update the thumbnails to display 
	void UpdateThumbnails();

	///	\brief	Creates a list of visible thumbnails to draw
	///	\return true if successful
	bool VisibleThumbnails();

	/// \brief	Load or save the contents of ResourceMap
	///	\param	*archive - ptr to the archive
	void LoadSaveResourceMap( CArchive * archive );

	//May want to moves these to another .cpp/.h
	//Thread---------------------------------------------------------------------------------------------
	static void FillResourcesThread();
	static bool ProcessThreadMessages();
	static void StartWatchThread( const TCHAR * directory, HWND parentHandle );	
	static void StopWatchThread();
	static int SendProcessedBatch( HWND ParentHandle, FINDDATALIST &out_list, int maxsteps );			

	///	\brief	generates thumbnail for passed filename
	///			uses both EE or Windows Shell as thumbnail generator
	///	\param	filepath - path to file
	///	\return	HBITMAP with generated thumbnail. Caller owns the bitmap handle
	static HBITMAP GenerateThumbnail( LPCTSTR filepath );

	///	\brief	generates thumbnail for passed filename using Windows Shell
	///	\param	filepath - path to file
	///	\return	HBITMAP with generated thumbnail. Caller owns the bitmap handle
	static HBITMAP GetThumbnailFromShell( LPCTSTR filepath );
	static CBitmap *CreateThumbnail( CDC *pDC, HBITMAP hSrc );

	static bool ActivateOpenedDocument(LPCTSTR szFilename);
	
	//thread handle for resource thumbnails
	static DWORD		m_ResourceThumbnailThreadID;
	static HANDLE		m_ResourceThumbnailThreadHandle;	
	static HANDLE		m_ResourceWatchThreadHandle;
	static int			m_ObjectCount;
	static bool			m_PauseThumbnailGenerationThread;	
	static bool			m_bInteruptFlag;

	// File change notification thread-------------------------------------------------------------------
	static void WatchDirectoryThread( POPULATERESOURCELISTPARAMS * params );
	//---------------------------------------------------------------------------------------------------
	// Generated message map functions
	//{{AFX_MSG(CResourcePage)
	virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	afx_msg void OnBegindragResourcesList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnNMDblclkObjectsList(NMHDR *pNMHDR, LRESULT *pResult);
	afx_msg void OnContextMenu(CWnd* /*pWnd*/, CPoint /*point*/);
	//}}AFX_MSG
	afx_msg LRESULT OnAddMessage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnFolderRefreshMessage( WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnFileChangedMessage( WPARAM wParam, LPARAM lParam );
	afx_msg LRESULT OnResetInteruptMessage( WPARAM wParam, LPARAM lParam );
	DECLARE_MESSAGE_MAP()

public:
	// on these messages, update the visible thumbnails list
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RESOURCEPAGE_H__53730D09_4C39_4B92_9A4B_8BE03DAE955F__INCLUDED_)
